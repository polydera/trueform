---
title: Core
description: Polydata, zero-copy views, and data conversion utilities.
navigation:
  icon: i-lucide-atom
---

The core module bridges VTK and trueform. It provides zero-copy views that expose VTK data through trueform's semantic ranges—[`tf::points`](/cpp/modules/core#points-and-vectors), [`tf::polygons`](/cpp/modules/core#polygons), [`tf::curves`](/cpp/modules/core#paths-and-curves), and more—so you get the same ease of use and composability on VTK objects. Conversion utilities handle the reverse direction, turning trueform [buffers](/cpp/modules/core#data-structures-and-buffers) back into VTK objects. The [`tf::vtk::polydata`](#tfvtkpolydata) class extends `vtkPolyData` with cached acceleration structures for repeated queries.

Include the module with:

```cpp
#include <trueform/vtk/core.hpp>
```

## tf::vtk::polydata

A `vtkPolyData` subclass that adds lazy-built, MTime-tracked acceleration structures. Structures rebuild automatically when the underlying mesh data changes.

### Creation

```cpp
// Create new polydata
auto mesh = vtkSmartPointer<tf::vtk::polydata>::New();

// Wrap existing vtkPolyData (zero-copy)
mesh->ShallowCopy(reader->GetOutput());

// Detect in VTK pipelines
if (auto* tf_poly = tf::vtk::polydata::SafeDownCast(input)) {
    // Use cached structures
}

// Retrieve from filter input (creates if needed)
auto* poly = tf::vtk::polydata::GetData(inputVector, 0);
```

### Geometry Views

Access mesh data as trueform views. See [Primitive Ranges and Views](/cpp/modules/core#primitive-ranges-and-views) for details on each type.

#### points()

Returns a [`tf::points`](/cpp/modules/core#points-and-vectors) view over the mesh vertices. Each element is a [`tf::point_view`](/cpp/modules/core#points-and-vectors).

```cpp
for (auto pt : mesh->points()) {
    auto [x, y, z] = pt;
}
```

#### polys()

Returns a [`tf::offset_block_range`](/cpp/modules/core#offset-block-range) view over face connectivity. Each element is a variable-length block of vertex indices.

```cpp
for (auto face : mesh->polys()) {
    for (auto vertex_id : face) { /* ... */ }
}
```

#### polygons()

Returns a [`tf::polygons`](/cpp/modules/core#polygons) view combining face indices with point coordinates. Each element is a [`tf::polygon`](/cpp/modules/core#polygon) providing both geometry and indices.

```cpp
for (auto polygon : mesh->polygons()) {
    for (auto pt : polygon) { /* point_view */ }
    for (auto id : polygon.indices()) { /* vertex index */ }
}
```

#### paths()

Returns a [`tf::paths`](/cpp/modules/core#paths-and-curves) view over line connectivity. Each path is a variable-length sequence of vertex indices.

```cpp
for (auto path : mesh->paths()) {
    for (auto vertex_id : path) { /* ... */ }
}
```

#### curves()

Returns a [`tf::curves`](/cpp/modules/core#paths-and-curves) view combining path indices with point coordinates. Each element is a curve providing both geometry and indices.

```cpp
for (auto curve : mesh->curves()) {
    for (auto pt : curve) { /* point_view */ }
    for (auto id : curve.indices()) { /* vertex index */ }
}
```

#### edges() and segments()

Returns [`tf::edges`](/cpp/modules/core#edges-and-faces) and [`tf::segments`](/cpp/modules/core#segments) views built from line data. Edges are pairs of vertex indices; each [`tf::segment`](/cpp/modules/core#segment) combines an edge with point coordinates.

```cpp
for (auto edge : mesh->edges()) {
    auto [v0, v1] = edge;
}

for (auto segment : mesh->segments()) {
    auto [pt0, pt1] = segment;
}
```

### Normals

Returns [`tf::unit_vectors`](/cpp/modules/core#points-and-vectors) views over normal data. Each element is a [`tf::unit_vector_view`](/cpp/modules/core#points-and-vectors). Empty if no normals are present.

```cpp
auto pn = mesh->point_normals();
if (pn.size() > 0) {
    for (auto normal : pn) { /* unit_vector_view */ }
}

auto cn = mesh->cell_normals();
```

### Cached Structures

All structures are built lazily on first access and cached. They automatically rebuild when VTK's MTime indicates data has changed.

#### Spatial Trees

Returns [`tf::aabb_tree`](/cpp/modules/spatial#aabb-tree) structures for accelerated spatial queries.

```cpp
const auto& poly_tree = mesh->poly_tree();      // polygon bounding boxes
const auto& seg_tree = mesh->segment_tree();    // line segment bounding boxes
const auto& pt_tree = mesh->point_tree();       // point bounding boxes
```

#### Topology Structures

Returns connectivity structures from the [Topology module](/cpp/modules/topology#connectivity-structures).

| Method | Returns | Description |
|--------|---------|-------------|
| `face_membership()` | [`tf::face_membership`](/cpp/modules/topology#face-membership) | For each vertex, list of faces containing it |
| `manifold_edge_link()` | [`tf::manifold_edge_link`](/cpp/modules/topology#manifold-edge-link) | Edge adjacency info (boundary, manifold status) |
| `face_link()` | [`tf::face_link`](/cpp/modules/topology#face-link) | For each face, list of adjacent faces |
| `vertex_link()` | [`tf::vertex_link`](/cpp/modules/topology#vertex-link) | For each vertex, list of neighboring vertices |

```cpp
const auto& fm = mesh->face_membership();
const auto& mel = mesh->manifold_edge_link();
const auto& fl = mesh->face_link();
const auto& vl = mesh->vertex_link();
```

#### Edge Buffer

Returns a [`tf::blocked_buffer`](/cpp/modules/core#blocked-buffer) of edge pairs extracted from line data.

```cpp
const auto& edges = mesh->edges_buffer();  // tf::blocked_buffer<vtkIdType, 2>
```

## VTK → trueform Views

Zero-copy views over VTK data. These functions wrap VTK memory without copying—the returned views are valid only while the source VTK object exists. Once wrapped, you can use trueform's full API: iterate, query, pass to algorithms.

### Geometry

Wrap VTK geometry as trueform ranges. Use the dynamic variants for mixed meshes (tri/quad/n-gon), or the sized variants when the topology is uniform.

| Factory | Input | Returns | Element |
|---------|-------|---------|---------|
| `make_points` | `vtkPoints*` or `vtkPolyData*` | `points_t` | [`tf::point_view`](/cpp/modules/core#points-and-vectors) |
| `make_polys` | `vtkCellArray*` | `polys_t` | `tf::range<vtkIdType*, tf::dynamic_size>` |
| `make_polys<V>` | `vtkCellArray*` | `polys_sized_t<V>` | `tf::range<vtkIdType*, V>` |
| `make_polygons` | `vtkPolyData*` | `polygons_t` | [`tf::polygon`](/cpp/modules/core#polygon) |
| `make_polygons<V>` | `vtkPolyData*` | `polygons_sized_t<V>` | [`tf::polygon`](/cpp/modules/core#polygon) |
| `make_paths` | `vtkCellArray*` | `paths_t` | `tf::range<vtkIdType*, tf::dynamic_size>` |
| `make_curves` | `vtkPolyData*` | `curves_t` | [`tf::curve`](/cpp/modules/core#paths-and-curves) |
| `make_lines` | `vtkCellArray*` | `lines_t` | `tf::range<vtkIdType*, tf::dynamic_size>` |
| `make_lines<V>` | `vtkCellArray*` | `lines_sized_t<V>` | `tf::range<vtkIdType*, V>` |

```cpp
// Points from vtkPolyData
auto points = tf::vtk::make_points(polydata);

// Polygons (dynamic size - handles mixed tri/quad/n-gon)
auto polygons = tf::vtk::make_polygons(polydata);

// Triangles only (compile-time size)
auto triangles = tf::vtk::make_polygons<3>(polydata);

// Curves from line data
auto curves = tf::vtk::make_curves(polydata);
```

### Normals

| Factory | Input | Returns | Element |
|---------|-------|---------|---------|
| `make_point_normals` | `vtkPolyData*` | `normals_t` | [`tf::unit_vector_view`](/cpp/modules/core#points-and-vectors) |
| `make_cell_normals` | `vtkPolyData*` | `normals_t` | [`tf::unit_vector_view`](/cpp/modules/core#points-and-vectors) |

```cpp
auto point_normals = tf::vtk::make_point_normals(polydata);
auto cell_normals = tf::vtk::make_cell_normals(polydata);
// Returns empty view if no normals present
```

### Arrays

Wrap VTK arrays as trueform ranges for scalar fields, per-vertex attributes, or any array data.

| Factory | Input | Returns | Element |
|---------|-------|---------|---------|
| `make_range` | `vtkFloatArray*` | `float_range_t` | `float` |
| `make_range` | `vtkDoubleArray*` | `double_range_t` | `double` |
| `make_range` | `vtkIntArray*` | `int_range_t` | `int` |
| `make_range` | `vtkIdTypeArray*` | `vtkIdType_range_t` | `vtkIdType` |
| `make_blocked_range<V>` | `vtk*Array*` | blocked range (static) | `tf::range<T*, V>` |
| `make_blocked_range` | `vtk*Array*`, size | blocked range (dynamic) | `tf::range<T*, tf::dynamic_size>` |
| `make_byte_blocks` | `vtkDataArray*` | `byte_blocks_t` | `tf::range<unsigned char*, tf::dynamic_size>` |

```cpp
// Flat range over array data
auto scalars = tf::vtk::make_range(floatArray);

// Blocked access (e.g., RGB tuples)
auto colors = tf::vtk::make_blocked_range<3>(colorArray);

// Dynamic block size
auto tuples = tf::vtk::make_blocked_range(array, tuple_size);

// Raw byte access per tuple
auto bytes = tf::vtk::make_byte_blocks(dataArray);
```

## trueform → VTK Buffers

After processing with trueform algorithms, convert results back to VTK objects. All functions have two overloads:
- `const&` - copies data
- `&&` - moves data (zero-copy when possible)

### Geometry

Convert trueform geometry buffers to `vtkPolyData` or its components.

| Factory | Input | Output |
|---------|-------|--------|
| `make_vtk_points` | [`tf::points_buffer`](/cpp/modules/core#points-buffer) | `vtkSmartPointer<vtkPoints>` |
| `make_vtk_cells` | [`tf::blocked_buffer`](/cpp/modules/core#blocked-buffer) | `vtkSmartPointer<vtkCellArray>` |
| `make_vtk_cells` | [`tf::offset_block_buffer`](/cpp/modules/core#offset-block-buffer) | `vtkSmartPointer<vtkCellArray>` |
| `make_vtk_polydata` | [`tf::polygons_buffer`](/cpp/modules/core#polygons-buffer) | `vtkSmartPointer<vtkPolyData>` |
| `make_vtk_polydata` | [`tf::curves_buffer`](/cpp/modules/core#curves-buffer) | `vtkSmartPointer<vtkPolyData>` |
| `make_vtk_polydata` | [`tf::segments_buffer`](/cpp/modules/core#segments-buffer) | `vtkSmartPointer<vtkPolyData>` |

```cpp
// From polygons buffer (move for zero-copy)
tf::polygons_buffer<vtkIdType, float, 3, tf::dynamic_size> result;
// ... fill result ...
auto polydata = tf::vtk::make_vtk_polydata(std::move(result));

// From curves buffer
tf::curves_buffer<vtkIdType, float, 3> curves;
// ... fill curves ...
auto lines = tf::vtk::make_vtk_polydata(std::move(curves));
```

### Normals

| Factory | Input | Output |
|---------|-------|--------|
| `make_vtk_normals` | [`tf::unit_vectors_buffer`](/cpp/modules/core#unit-vectors-buffer) | `vtkSmartPointer<vtkFloatArray>` |

```cpp
auto normals = tf::compute_normals(polygons);
auto vtk_normals = tf::vtk::make_vtk_normals(std::move(normals));
vtk_normals->SetName("Normals");
polydata->GetCellData()->SetNormals(vtk_normals);
```

### Arrays

| Factory | Input | Output |
|---------|-------|--------|
| `make_vtk_array` | [`tf::buffer`](/cpp/modules/core#basic-buffer) | `vtkSmartPointer<vtk*Array>` |

```cpp
tf::buffer<int> labels;
// ... fill labels ...
auto vtk_labels = tf::vtk::make_vtk_array(std::move(labels));
vtk_labels->SetName("Labels");
polydata->GetCellData()->AddArray(vtk_labels);
```

### Reindexing

When mesh topology changes (cleaning, boolean operations), point and cell data must be remapped. These utilities apply [index maps](/cpp/modules/core#index-maps) to preserve VTK attributes through such operations.

| Factory | Input | Output |
|---------|-------|--------|
| `make_vtk_array_reindexed` | `vtkDataArray*`, `tf::index_map_buffer` | `vtkSmartPointer<vtkDataArray>` |
| `make_vtk_point_data_reindexed` | `vtkPointData*`, `tf::index_map_buffer` | `vtkSmartPointer<vtkPointData>` |
| `make_vtk_cell_data_reindexed` | `vtkCellData*`, `tf::index_map_buffer` | `vtkSmartPointer<vtkCellData>` |

```cpp
tf::index_map_buffer<vtkIdType> point_map;
// ... build map during mesh cleaning ...

// Reindex all point data arrays
auto new_point_data = tf::vtk::make_vtk_point_data_reindexed(
    input->GetPointData(), point_map);
output->GetPointData()->ShallowCopy(new_point_data);
```

## Transform Utilities

Convert between trueform [transformations](/cpp/modules/core#transformations-and-frames) and VTK matrices. Use these when working with actor transforms or building world-space rays for picking.

| Factory | Input | Output |
|---------|-------|--------|
| `make_frame` | `vtkMatrix4x4*` | [`tf::frame`](/cpp/modules/core#transformations-and-frames) |
| `fill_frame` | `tf::frame<T, 3>&`, `vtkMatrix4x4*` | void |
| `make_vtk_matrix` | `tf::transformation<T, 3>` | `vtkSmartPointer<vtkMatrix4x4>` |
| `fill_vtk_matrix` | `vtkMatrix4x4*`, `tf::transformation<T, 3>` | void |
| `make_vtk_transform` | `tf::transformation<T, 3>` | `vtkSmartPointer<vtkTransform>` |
| `fill_vtk_transform` | `vtkTransform*`, `tf::transformation<T, 3>` | void |
| `make_world_ray` | `vtkRenderer*`, x, y | [`tf::ray`](/cpp/modules/core#line-and-ray) |

```cpp
// VTK matrix → trueform frame
auto frame = tf::vtk::make_frame(actor->GetUserMatrix());
auto form = mesh->polygons() | tf::tag(mesh->poly_tree()) | tf::tag(frame);

// trueform transformation → VTK matrix
auto transform = tf::random_transformation<float, 3>();
auto matrix = tf::vtk::make_vtk_matrix(transform);
actor->SetUserMatrix(matrix);

// Update existing matrix
tf::vtk::fill_vtk_matrix(actor->GetUserMatrix(), new_transform);

// Screen-space picking ray
auto ray = tf::vtk::make_world_ray(renderer, mouse_x, mouse_y);
if (auto hit = tf::vtk::ray_hit(ray, mesh)) {
    // Process hit
}
```

## Type Aliases

For convenience, the module provides type aliases for the most common view types. These match the return types of the factory functions above.

```cpp
// Geometry views
using points_t = /* tf::points view over float data */;
using polys_t = /* tf::offset_block_range over vtkIdType */;
using polygons_t = /* tf::polygons (polys + points) */;
using paths_t = /* tf::paths view */;
using curves_t = /* tf::curves (paths + points) */;
using lines_t = /* tf::offset_block_range over vtkIdType */;
using edges_t = /* tf::edges view */;
using segments_t = /* tf::segments (edges + points) */;
using normals_t = /* tf::unit_vectors view */;

// Sized variants (compile-time vertex count)
template<std::size_t V> using polys_sized_t = /* ... */;
template<std::size_t V> using polygons_sized_t = /* ... */;
template<std::size_t V> using lines_sized_t = /* ... */;

// Array ranges
using float_range_t = tf::range<float*, tf::dynamic_size>;
using double_range_t = tf::range<double*, tf::dynamic_size>;
using int_range_t = tf::range<int*, tf::dynamic_size>;
using vtkIdType_range_t = tf::range<vtkIdType*, tf::dynamic_size>;
```

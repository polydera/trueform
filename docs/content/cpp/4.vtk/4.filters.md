---
title: Filters
description: VTK pipeline filters wrapping trueform algorithms.
navigation:
  icon: i-lucide-filter
---

Filters integrate trueform algorithms into VTK's pipeline architecture. Connect them like any VTK filter—they handle caching, MTime tracking, and data conversion automatically. Each filter wraps a corresponding [function](/cpp/vtk/functions) for use in pipelines.

Include the module with:

```cpp
#include <trueform/vtk/filters.hpp>
```

## Pipeline Pattern

Most filters require [`tf::vtk::polydata`](/cpp/vtk/core#tfvtkpolydata) input for access to cached acceleration structures. Use the [adapter](#adapter) filter to convert standard `vtkPolyData`:

```cpp
vtkNew<vtkSTLReader> reader;
reader->SetFileName("mesh.stl");

// Convert to tf::vtk::polydata
vtkNew<tf::vtk::adapter> adapter;
adapter->SetInputConnection(reader->GetOutputPort());

// Now use trueform filters
vtkNew<tf::vtk::boolean> boolean_filter;
boolean_filter->SetInputConnection(0, adapter0->GetOutputPort());
boolean_filter->SetInputConnection(1, adapter1->GetOutputPort());
```

Alternatively, use the [stl_reader](#stl_reader) or [obj_reader](#obj_reader) filters which output `tf::vtk::polydata` directly.

## adapter

Converts `vtkPolyData` to [`tf::vtk::polydata`](/cpp/vtk/core#tfvtkpolydata) with cached acceleration structures. The cached polydata persists between pipeline executions—structures only rebuild when input data changes.

```cpp
vtkNew<tf::vtk::adapter> adapter;
adapter->SetInputConnection(reader->GetOutputPort());
adapter->Update();

// Access cached polydata directly
auto* poly = adapter->cached_polydata();
```

| Port | Direction | Type |
|------|-----------|------|
| 0 | Input | `vtkPolyData` |
| 0 | Output | `tf::vtk::polydata` |

## Boolean & Intersection

### boolean

Computes boolean operations between two meshes. Wraps [`make_boolean`](/cpp/vtk/functions#make_boolean).

| Port | Direction | Type | Description |
|------|-----------|------|-------------|
| 0 | Input | `tf::vtk::polydata` | First mesh |
| 1 | Input | `tf::vtk::polydata` | Second mesh |
| 0 | Output | `tf::vtk::polydata` | Result mesh with "Labels" cell data |
| 1 | Output | `tf::vtk::polydata` | Intersection curves (if enabled) |

| Method | Description |
|--------|-------------|
| `set_operation(tf::boolean_op)` | Set operation: `merge`, `intersection`, `difference` |
| `set_return_curves(bool)` | Enable curves output on port 1 |
| `set_matrix0(vtkMatrix4x4*)` | Transform for first input |
| `set_matrix1(vtkMatrix4x4*)` | Transform for second input |

```cpp
vtkNew<tf::vtk::boolean> filter;
filter->SetInputConnection(0, adapter0->GetOutputPort());
filter->SetInputConnection(1, adapter1->GetOutputPort());
filter->set_operation(tf::boolean_op::difference);
filter->set_return_curves(true);
filter->Update();

auto* result = filter->GetOutput(0);  // mesh with "Labels"
auto* curves = filter->GetOutput(1);  // intersection curves
```

### intersection_curves

Computes intersection curves between two meshes without performing a boolean operation. Wraps [`make_intersection_curves`](/cpp/vtk/functions#make_intersection_curves).

| Port | Direction | Type | Description |
|------|-----------|------|-------------|
| 0 | Input | `tf::vtk::polydata` | First mesh |
| 1 | Input | `tf::vtk::polydata` | Second mesh |
| 0 | Output | `tf::vtk::polydata` | Intersection curves |

| Method | Description |
|--------|-------------|
| `set_matrix0(vtkMatrix4x4*)` | Transform for first input |
| `set_matrix1(vtkMatrix4x4*)` | Transform for second input |

```cpp
vtkNew<tf::vtk::intersection_curves> filter;
filter->SetInputConnection(0, adapter0->GetOutputPort());
filter->SetInputConnection(1, adapter1->GetOutputPort());
filter->set_matrix0(actor0->GetUserMatrix());
filter->set_matrix1(actor1->GetUserMatrix());
filter->Update();

auto* curves = filter->GetOutput();
```

### self_intersection_resolver

Finds where a mesh intersects itself and embeds the intersection curves as edges. Wraps [`resolved_self_intersections`](/cpp/vtk/functions#resolved_self_intersections).

| Port | Direction | Type | Description |
|------|-----------|------|-------------|
| 0 | Input | `tf::vtk::polydata` | Input mesh |
| 0 | Output | `tf::vtk::polydata` | Resolved mesh |
| 1 | Output | `tf::vtk::polydata` | Self-intersection curves (if enabled) |

| Method | Description |
|--------|-------------|
| `set_return_curves(bool)` | Enable curves output on port 1 |

```cpp
vtkNew<tf::vtk::self_intersection_resolver> filter;
filter->SetInputConnection(adapter->GetOutputPort());
filter->set_return_curves(true);
filter->Update();

auto* resolved = filter->GetOutput(0);
auto* curves = filter->GetOutput(1);
```

## Scalar Field Operations

### isocontours

Extracts isocontour curves from scalar fields on mesh vertices. Wraps [`make_isocontours`](/cpp/vtk/functions#make_isocontours).

| Port | Direction | Type | Description |
|------|-----------|------|-------------|
| 0 | Input | `vtkPolyData` | Mesh with point scalars |
| 0 | Output | `vtkPolyData` | Isocontour curves |

| Method | Description |
|--------|-------------|
| `set_scalars_name(string)` | Name of point scalars array (empty for active scalars) |
| `set_cut_values(vector<float>)` | Scalar values at which to extract contours |
| `add_cut_value(float)` | Add a single cut value |
| `clear_cut_values()` | Remove all cut values |

```cpp
vtkNew<tf::vtk::isocontours> filter;
filter->SetInputConnection(reader->GetOutputPort());
filter->set_scalars_name("temperature");
filter->set_cut_values({20.0f, 25.0f, 30.0f});
filter->Update();

auto* contours = filter->GetOutput();
```

### isobands

Extracts isoband regions between scalar values. Wraps [`make_isobands`](/cpp/vtk/functions#make_isobands).

| Port | Direction | Type | Description |
|------|-----------|------|-------------|
| 0 | Input | `vtkPolyData` | Mesh with point scalars |
| 0 | Output | `vtkPolyData` | Isoband polygons with "BandLabel" cell data |
| 1 | Output | `vtkPolyData` | Boundary curves (if enabled) |

| Method | Description |
|--------|-------------|
| `set_scalars_name(string)` | Name of point scalars array |
| `set_cut_values(vector<float>)` | Scalar values defining band boundaries |
| `set_selected_bands(vector<int>)` | Which bands to extract (band i is between cut i and i+1) |
| `set_return_curves(bool)` | Enable boundary curves output on port 1 |

```cpp
vtkNew<tf::vtk::isobands> filter;
filter->SetInputConnection(reader->GetOutputPort());
filter->set_scalars_name("elevation");
filter->set_cut_values({0.0f, 0.5f, 1.0f, 1.5f});
filter->set_selected_bands({1, 2});  // bands between 0.5-1.0 and 1.0-1.5
filter->set_return_curves(true);
filter->Update();

auto* bands = filter->GetOutput(0);   // polygons with "BandLabel"
auto* curves = filter->GetOutput(1);  // boundary curves
```

## Topology Analysis

### connected_components

Labels connected components in a mesh. Wraps [`make_connected_components`](/cpp/vtk/functions#make_connected_components).

| Port | Direction | Type | Description |
|------|-----------|------|-------------|
| 0 | Input | `tf::vtk::polydata` | Input mesh |
| 0 | Output | `tf::vtk::polydata` | Mesh with "ComponentLabel" cell data |

| Method | Description |
|--------|-------------|
| `set_connectivity(tf::connectivity_type)` | How faces connect (see below) |
| `n_components()` | Number of components found (after Update) |

Connectivity types:
- `tf::connectivity_type::manifold_edge` — only through manifold edges (separates at boundaries/non-manifold)
- `tf::connectivity_type::edge` — through any shared edge
- `tf::connectivity_type::vertex` — through any shared vertex (most permissive)

```cpp
vtkNew<tf::vtk::connected_components> filter;
filter->SetInputConnection(adapter->GetOutputPort());
filter->set_connectivity(tf::connectivity_type::edge);
filter->Update();

int n = filter->n_components();
auto* labeled = filter->GetOutput();  // has "ComponentLabel" cell data
```

### boundary_paths

Extracts boundary edges connected into continuous paths. Wraps [`make_boundary_paths`](/cpp/vtk/functions#make_boundary_paths).

| Port | Direction | Type | Description |
|------|-----------|------|-------------|
| 0 | Input | `vtkPolyData` | Input mesh |
| 0 | Output | `vtkPolyData` | Boundary curves (shares points with input) |

```cpp
vtkNew<tf::vtk::boundary_paths> filter;
filter->SetInputConnection(reader->GetOutputPort());
filter->Update();

auto* boundaries = filter->GetOutput();
```

### non_simple_edges

Extracts boundary and/or non-manifold edges. Wraps [`make_non_simple_edges`](/cpp/vtk/functions#make_non_simple_edges), [`make_boundary_edges`](/cpp/vtk/functions#make_boundary_edges), and [`make_non_manifold_edges`](/cpp/vtk/functions#make_non_manifold_edges).

| Port | Direction | Type | Description |
|------|-----------|------|-------------|
| 0 | Input | `tf::vtk::polydata` | Input mesh |
| 0 | Output | `vtkPolyData` | Edges with "EdgeType" cell data (if both types enabled) |

| Method | Description |
|--------|-------------|
| `set_boundary_edges(bool)` | Include boundary edges (default: true) |
| `set_non_manifold_edges(bool)` | Include non-manifold edges (default: true) |

Edge types in "EdgeType" cell data:
- `0` — boundary edge (used by one face)
- `1` — non-manifold edge (used by three or more faces)

```cpp
vtkNew<tf::vtk::non_simple_edges> filter;
filter->SetInputConnection(adapter->GetOutputPort());
filter->set_boundary_edges(true);
filter->set_non_manifold_edges(true);
filter->Update();

auto* edges = filter->GetOutput();  // has "EdgeType" if both enabled
```

## Geometry

### normals_generator

Computes normals and optionally orients faces. Wraps [`orient_faces_consistently`](/cpp/vtk/functions#orient_faces_consistently), [`ensure_positive_orientation`](/cpp/vtk/functions#ensure_positive_orientation), [`compute_cell_normals`](/cpp/vtk/functions#compute_cell_normals), and [`compute_point_normals`](/cpp/vtk/functions#compute_point_normals).

| Port | Direction | Type | Description |
|------|-----------|------|-------------|
| 0 | Input | `vtkPolyData` | Input mesh |
| 0 | Output | `vtkPolyData` | Mesh with "Normals" cell/point data |

| Method | Default | Description |
|--------|---------|-------------|
| `set_orient_faces(bool)` | `true` | Orient faces for consistent winding |
| `set_positive_orientation(bool)` | `false` | Ensure outward-facing normals (implies orient_faces) |
| `set_compute_point_normals(bool)` | `true` | Compute vertex normals (cell normals always computed) |

Operations are performed in order:
1. Orient faces: positive orientation, or just consistent (if enabled)
2. Compute cell normals (always)
3. Compute point normals (if enabled)

```cpp
vtkNew<tf::vtk::normals_generator> filter;
filter->SetInputConnection(reader->GetOutputPort());
filter->set_orient_faces(true);
filter->set_positive_orientation(true);  // outward-facing normals
filter->set_compute_point_normals(true);
filter->Update();

auto* mesh = filter->GetOutput();
// mesh->GetCellData()->GetNormals()
// mesh->GetPointData()->GetNormals()
```

### curvatures_generator

Computes principal curvatures at each vertex. Wraps [`compute_principal_curvatures`](/cpp/vtk/functions#compute_principal_curvatures).

| Port | Direction | Type | Description |
|------|-----------|------|-------------|
| 0 | Input | `tf::vtk::polydata` | Input mesh |
| 0 | Output | `tf::vtk::polydata` | Mesh with curvature data |

| Method | Default | Description |
|--------|---------|-------------|
| `set_k(int)` | `2` | K-ring neighborhood size for quadric fitting |
| `set_compute_directions(bool)` | `false` | Also compute principal directions |

Output arrays on point data:
- `"K1"`, `"K2"` — principal curvatures (always computed)
- `"D1"`, `"D2"` — principal directions (if `compute_directions` enabled)

```cpp
vtkNew<tf::vtk::curvatures_generator> filter;
filter->SetInputConnection(adapter->GetOutputPort());
filter->set_k(2);
filter->set_compute_directions(true);
filter->Update();

auto* mesh = filter->GetOutput();
// mesh->GetPointData()->GetArray("K1")  // max curvature
// mesh->GetPointData()->GetArray("K2")  // min curvature
// mesh->GetPointData()->GetArray("D1")  // max curvature direction
// mesh->GetPointData()->GetArray("D2")  // min curvature direction
```

### triangulator

Triangulates all polygons using ear-cutting. Wraps [`triangulated`](/cpp/vtk/functions#triangulated).

| Port | Direction | Type | Description |
|------|-----------|------|-------------|
| 0 | Input | `tf::vtk::polydata` | Input mesh |
| 0 | Output | `tf::vtk::polydata` | Triangulated mesh |

| Method | Default | Description |
|--------|---------|-------------|
| `set_preserve_point_data(bool)` | `true` | Preserve point data arrays |

::note{icon="i-lucide-info"}
Cell data is not preserved since face count changes during triangulation.
::

```cpp
vtkNew<tf::vtk::triangulator> filter;
filter->SetInputConnection(adapter->GetOutputPort());
filter->set_preserve_point_data(true);
filter->Update();

auto* triangles = filter->GetOutput();
```

## Cleaning

### polygon_cleaner

Removes duplicate points and degenerate faces. Wraps [`cleaned_polygons`](/cpp/vtk/functions#cleaned_polygons).

| Port | Direction | Type | Description |
|------|-----------|------|-------------|
| 0 | Input | `vtkPolyData` | Input mesh |
| 0 | Output | `vtkPolyData` | Cleaned mesh |

| Method | Default | Description |
|--------|---------|-------------|
| `set_tolerance(float)` | `0` | Distance for merging points (0 = exact duplicates) |
| `set_preserve_data(bool)` | `true` | Remap point/cell data arrays |

```cpp
vtkNew<tf::vtk::polygon_cleaner> filter;
filter->SetInputConnection(reader->GetOutputPort());
filter->set_tolerance(1e-6f);
filter->set_preserve_data(true);
filter->Update();

auto* clean = filter->GetOutput();
```

### line_cleaner

Cleans line data: merges duplicate points, removes degenerate edges, and reconnects edges into continuous paths. Wraps [`cleaned_lines`](/cpp/vtk/functions#cleaned_lines).

| Port | Direction | Type | Description |
|------|-----------|------|-------------|
| 0 | Input | `vtkPolyData` | Input lines |
| 0 | Output | `vtkPolyData` | Cleaned paths |

| Method | Default | Description |
|--------|---------|-------------|
| `set_tolerance(float)` | `0` | Distance for merging points |
| `set_preserve_data(bool)` | `true` | Remap point data arrays |

::note{icon="i-lucide-info"}
Cell data cannot be preserved because edges are reconnected into paths.
::

```cpp
vtkNew<tf::vtk::line_cleaner> filter;
filter->SetInputConnection(curves_source->GetOutputPort());
filter->set_tolerance(1e-6f);
filter->Update();

auto* clean = filter->GetOutput();
```

## File I/O

These readers output [`tf::vtk::polydata`](/cpp/vtk/core#tfvtkpolydata) directly, with cached acceleration structures ready for use. They wrap the corresponding [I/O functions](/cpp/vtk/functions#file-io).

### stl_reader

Reads an STL file. Wraps [`read_stl`](/cpp/vtk/functions#read_stl).

| Port | Direction | Type | Description |
|------|-----------|------|-------------|
| 0 | Output | `tf::vtk::polydata` | Loaded mesh with cached structures |

| Method | Description |
|--------|-------------|
| `set_file_name(string)` | Path to STL file |

::note{icon="i-lucide-info"}
Normals are not read from the file.
::

```cpp
vtkNew<tf::vtk::stl_reader> reader;
reader->set_file_name("model.stl");
reader->Update();

// Output is tf::vtk::polydata - no adapter needed
vtkNew<tf::vtk::boolean> boolean_filter;
boolean_filter->SetInputConnection(0, reader0->GetOutputPort());
boolean_filter->SetInputConnection(1, reader1->GetOutputPort());
```

### obj_reader

Reads an OBJ file. Wraps [`read_obj`](/cpp/vtk/functions#read_obj).

| Port | Direction | Type | Description |
|------|-----------|------|-------------|
| 0 | Output | `tf::vtk::polydata` | Loaded mesh with cached structures |

| Method | Description |
|--------|-------------|
| `set_file_name(string)` | Path to OBJ file |

::note{icon="i-lucide-info"}
Only vertices and faces are read. Normals and texture coordinates are not read.
::

```cpp
vtkNew<tf::vtk::obj_reader> reader;
reader->set_file_name("model.obj");
reader->Update();

auto* mesh = reader->GetOutput();
```

---
title: Intersect
description: Compute intersection curves between meshes and scalar field isocontours.
path: /py/modules/intersect
navigation:
  icon: i-lucide-squares-intersect
---

The Intersect module computes intersection curves between geometric objects and extracts isocontours from scalar fields.

## Intersection Curves

Compute intersection curves between two 3D meshes:

```python
import trueform as tf
import numpy as np

# Load two meshes (must be 3D and have matching dtypes)
faces1, points1 = tf.read_stl("mesh1.stl")
faces2, points2 = tf.read_stl("mesh2.stl")
mesh1 = tf.Mesh(faces1, points1)
mesh2 = tf.Mesh(faces2, points2)

# Optionally add transformations to one or both
mesh1.transformation = np.eye(4, dtype=np.float32)

# Compute intersection curves between the two meshes
paths, curve_points = tf.intersection_curves(mesh1, mesh2)

# paths: OffsetBlockedArray of curve paths (each path is a sequence of point indices)
# curve_points: numpy array of 3D intersection points

print(f"Number of curves: {len(paths)}")
print(f"Number of curve points: {len(curve_points)}")

# Iterate over each curve
for i, path_ids in enumerate(paths):
    # Get the points for this curve
    pts = curve_points[path_ids]
    print(f"Curve {i}: {len(pts)} points")
```

The function returns:
- **paths**: `OffsetBlockedArray` where each element contains indices into `curve_points`, representing one curve
- **curve_points**: numpy array of shape `(N, 3)` containing all curve vertices

**Requirements:**
- Both meshes must be 3D
- Both meshes must have matching dtypes (both float32 or both float64)
- Requires Mesh objects (not tuples) because topology is needed
- Works with both triangle meshes and dynamic meshes (n-gons via `OffsetBlockedArray`)

### Self-Intersection Curves

Find curves where a mesh intersects itself.

::tip{icon="i-lucide-scissors"}
To embed self-intersection curves into mesh topology, use [`tf.embedded_self_intersection_curves`](/py/modules/cut#embedded-self-intersection-curves) from the Cut module.
::

```python
import trueform as tf

# Load mesh that may have self-intersections
faces, points = tf.read_stl("mesh.stl")
mesh = tf.Mesh(faces, points)

# Find self-intersection curves
paths, curve_points = tf.self_intersection_curves(mesh)

print(f"Found {len(paths)} self-intersection curve(s)")

# Iterate over curves
for path_ids in paths:
    pts = curve_points[path_ids]
    # Process curve (e.g., visualize, repair, etc.)
```

**Requirements:**
- Mesh must be 3D
- Requires Mesh object (not tuple) because topology is needed
- Works with both triangle meshes and dynamic meshes

## Isocontours

Extract isocontour curves from scalar fields on meshes.

::tip{icon="i-lucide-scissors"}
To cut meshes into regions using isocontours, use [`tf.isobands`](/py/modules/cut#isobands) from the Cut module.
::

```python
# Load mesh
faces, points = tf.read_stl("terrain.stl")
mesh = tf.Mesh(faces, points)

# Create scalar field using distance to a plane (one value per vertex)
plane = tf.Plane(normal=[0, 0, 1], offset=0.0)
scalar_field = tf.distance_field(mesh.points, plane)

# Extract isocontours at specific threshold values
paths, contour_points = tf.isocontours(mesh, scalar_field, 0.0)

# paths: OffsetBlockedArray of contour paths
# contour_points: numpy array of contour vertices

print(f"Number of contours: {len(paths)}")
print(f"Number of contour points: {len(contour_points)}")

# Extract multiple isocontours
thresholds = np.array([0.0, 0.5, 1.0], dtype=np.float32)
paths, contour_points = tf.isocontours(mesh, scalar_field, thresholds)

# Iterate over each contour
for i, path_ids in enumerate(paths):
    # Get the points for this contour
    pts = contour_points[path_ids]
    print(f"Contour {i}: {len(pts)} points")
```

The function returns:
- **paths**: `OffsetBlockedArray` where each element contains indices into `contour_points`, representing one isocontour
- **contour_points**: numpy array of shape `(N, D)` where D is 2 or 3, containing all contour vertices

**Parameters:**
- **mesh**: Mesh object or tuple `(faces, points)`
- **scalar_field**: 1D numpy array with one value per mesh vertex, matching mesh dtype
- **threshold**: Single value or array of threshold values

**Use cases:**
- Extracting elevation contours from terrain data
- Visualizing level sets of physical quantities (temperature, pressure, etc.)
- Creating contour lines from implicit functions
- Analyzing stress distributions in FEA results

::tip{icon="i-lucide-info"}
For implementation details and low-level intersection access, see the [C++ Intersect](/cpp/modules/intersect) documentation.
::
